Возьмём код, который добавляет числа в массив, если они чётные наивным способом:

  while (howmany != 0) {
    val = random();
    if (val is odd) {
      out[index] = val;
      index += 1;
    }
    howmany--;
  }

  Этот код использует ~15 тактов ЦПУ на итерацию.

И безусловный код, делающий тоже самое немного иначе:

  while (howmany != 0) {
    val = random();
    out[index] = val;
    index += (val bitand 1);
    howmany--;
  }

  Этот код использует ~3 такта ЦПУ на итерацию.

На первой итерации шанс неудачного предсказания условия - 50%. Это значит, что компилятор
не может угадать, выполнится ли условие и заменить некоторый код местами во избежание
прыжков к другим инструкциям. Но вскоре процессор адаптируется, и шанс неудачных предсказаний
стремится к 0-5%.

При добавлении условия, можно сломать предсказывание условий ещё где-либо в другом месте. Чем больше
условий расположено рядом, тем процессору сложнее "обучаться", что повышает шанс ошибки.

