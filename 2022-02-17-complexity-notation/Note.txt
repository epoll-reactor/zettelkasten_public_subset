Для заданной функции g(n) запись Θ(g(n)) означает множество функций, таких, что
  Θ(g(n)) = { f(n): ∃ c1 > 0, c2 > 0, 0 <= c1*g(n) <= f(n) <= c2*g(n) ∀ n >= n0 }.
Иными словами, f(n) ограничена c1*g(n) снизу, и c2*g(n) сверху.

Поскольку Θ(g(n)) представляет собой множество, можно записать отношение как
f(n) ∈ Θ(g(n)).

В общем,

f(n) ∈ O(g(n)) - f(n) ограничена c*g(n) сверху;
f(n) ∈ Θ(g(n)) - f(n) ограничена c1*g(n) снизу и c2*g(n) сверху;
f(n) ∈ Ω(g(n)) - f(n) ограничена c*g(n) снизу.

Коэффициент C обычно выбирается так: c1 чуть меньше коэффициента самого старшего
(быстро растущего) слагаемого, с2 - чуть меньше.

Имея сложность an^2 + bn + c, после отрбасывания низших степеней и коэффициентов,
получим отношение f(n) ∈ Θ(n^2).

Поскольку любая константа - полином нулевой степени, постоянную можно выразить
как Θ(n^0) или Θ(1).

Для O(g(n)), имеем определение
  O(g(n)) = { f(n): ∃ c > 0, n0 > 0, 0 <= f(n) <= c*g(n) ∀ n >= n0 }.
Такая запись определяет верхнюю границу.

Для Ω(g(n)), имеем определение
  Ω(g(n)) = { f(n): ∃ c > 0, n0 > 0, 0 <= c*g(n) <= f(n) ∀ n >= n0 }.
Такая запись определяет нижнюю границу.

Из того, что f(n) ∈ Θ(g(n)) следует, что f(n) ∈ O(g(n)), поскольку Θ-обозначение
более мощное, чем O-обозначение. Также можно сказать, что
Θ(g(n)) ⊆ O(g(n)) (Θ является подмножеством O).

Любая, например, квадратичная функция принадлежит множеству Θ(n^2).

Выявление O-нотации несложно: достаточно лишь знать общую структуру алгоритма.
Например, наличие вложенного цикла свидетельствует о том, что наихудшее теори-
тически достигаемое время равняется O(n^2).

Интуитивно следует вывод, что для функций f(n) и g(n),
f(n) ⊆ Θ(g(n)) <=> f(n) ⊆ O(g(n)) ∧ f(n) ⊆ Ω(g(n)).

Когда мы говорим, что время работы алгоритма равняется Ω(g(n)), мы говорим,
что время работы алгоритма будет равно как минимум константе, умноженной на
g(n), то есть не быстрее, чем g(n). Например, наилучшее время сортировки
вставкой представляет собой Ω(n), откуда следует, что нотация сложности
всего алгоритма представляет собой Ω(n). Иными словами, время сортировки
вставкой принадлежит как Ω(n), так и O(n^2), поскольку оно распологается
между линейным и квадратичным временем.

Если мы имеем запись 2n^2 + 3n + 1 = 2n^2 + Θ(n), что эквивалентно
2n^2 + 3n + 1 = 2n^2 + f(n), где f(n) - некоторая неизвестная функция, принад-
лежащая множеству Θ(n).

Для o(g(n)) имеем определение
  o(g(n)) = { f(n): ∃ c > 0, n0 > 0, 0 <= f(n) < c*g(n) ∀ n >= n0 }.
Опредления O(f(n)) и o(f(n)) очень похожи, но O большое ограничивает функцию
неравенством 0 <= f(n) <= c*g(n) лишь для некоторой константы c > 0, в то время
как o(f(n)) ограничивает её неравенством 0 <= f(n) < c*g(n) для ВСЕХ констант
c > 0.

Например, 2n = o(n^2), но 2n^2 != o(n^2).

Ясно, что в о-обозначении f(n) пренебрежимо мала по сравнению с g(n) при n → ∞,
т.е. lim(n → ∞) f(n) / g(n) → 0.

Для ω(g(n)) имеем определение
  ω(g(n)) = { f(n): ∃ c > 0, n0 > 0, 0 <= c*g(n) < f(n) ∀ n >= n0 }.
Что является похожим на Ω(g(n)), но здесь c*g(n) строго меньше f(n).
То есть это "обратное" отношение по отношению к o(g(n)), из чего следует, что
  f(n) ⊆ ω(g(n)) <=> g(n) ⊆ o(f(n)).

Например, n^2/2 = ω(n), но n^2/2 != ω(n^2). Из соотношения f(n) ⊆ ω(g(n)) следует,
что lim(n → ∞) f(n) / g(n) → ∞, то есть f(n) становится сколь угодно большой по
сравнению с g(n) при n → ∞.

Свойства транзитивности:
  f(n) ⊆ Θ(g(n)) ∧ g(n) ⊆ Θ(h(n)) → f(n) ⊆ Θ(h(n));
  f(n) ⊆ O(g(n)) ∧ g(n) ⊆ O(h(n)) → f(n) ⊆ O(h(n));
  f(n) ⊆ Ω(g(n)) ∧ g(n) ⊆ Ω(h(n)) → f(n) ⊆ Ω(h(n));
  f(n) ⊆ o(g(n)) ∧ g(n) ⊆ o(h(n)) → f(n) ⊆ o(h(n));
  f(n) ⊆ ω(g(n)) ∧ g(n) ⊆ ω(h(n)) → f(n) ⊆ ω(h(n)).

Свойства рефлексивности:
  f(n) ⊆ Θ(f(n));
  f(n) ⊆ O(f(n));
  f(n) ⊆ Ω(f(n)).

Свойства симметрии:
  f(n) ⊆ Θ(g(n)) <=> g(n) ⊆ Θ(f(n)).
  
Свойства перестановочной симметрии:
  f(n) ⊆ O(g(n)) <=> g(n) ⊆ Ω(f(n));
  f(n) ⊆ o(g(n)) <=> g(n) ⊆ ω(f(n)).

Аналогия между асимптотической принадлежностью и простыми сравнениями чисел a и b:
  f(n) ⊆ Θ(g(n)) равносильно a  = b;
  f(n) ⊆ O(g(n)) равносильно a <= b;
  f(n) ⊆ o(g(n)) равносильно a <  b;
  f(n) ⊆ Ω(g(n)) равносильно a >= b;
  f(n) ⊆ ω(g(n)) равносильно a >  b;

Имея рекуррентное соотношение, например T(n) = 2T(n/2) + Θ(n), можно сказать,
что двойка (делитель) означает, на какое количество подзадач разбивается исход-
ная задача. Если, например, задача разбивается на 2/3 и 1/3 части, то рекуррент-
ное соотншоение выглядит как T(n) = T(2n/3) + T(n/3) + Θ(n).
Говоря иными словами, рекуррентное соотношение
T(n) = aT(n/b) + f(n), где a >= 1, b > 1, описывает алгоритм, работающий по
стратегии "разделяй и властвуй", который создаёт a подзадач, каждая из которых
имеет размер, равный 1/b размера исходной задачи, и шаги разделения и комбиниро-
вания которого в сумме занимают время f(n).

e^x = 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... = ∑ от i=0 до ∞ (x^i / i!).
ln(1 + x) = x - (x^2 / 2) + (x^3 / 3) - (x^4 / 4) + ... .
