well-formed программа - Программа на языке С++ сконструированная согласно
синтаксическим, семантическим правилам, а так же ODR
(правило одного определения).

ill-formed программа - Любая такая, что не подходит под определение well-formed.

Перегруженные операторы никогда не могут являться ассоциативными или
коммутативными.

#include вызывает рекурсивный повтор процесса разбора исходного кода и
подстановки его в файл. Все #include директивы после удаляются.
Все соседние строковые литералы конкатенируются. "a" "b" == "ab".

Алфавит С++ состоит из 96 символов:

a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " ’

Фрагмент "x+++++y" парсится как "x ++ ++ + y"

Альтернативные токены:

  +--------------------------+--------------------------+
  | Альтернативный | Главный | Альтернативный | Главный |
  +----------------+---------+----------------+---------+
  |             <% |       { |            and |      && |
  |             %> |       } |          bitor |       | |
  |             <: |       [ |             or |      || |
  |             :> |       ] |            xor |       ^ |
  |             %: |       # |          compl |       ~ |
  |           %:%: |      ## |         bitand |       & |
  |                |         |         and_eq |      &= |
  |                |         |          or_eq |      |= |
  |                |         |         xor_eq |      ^= |
  |                |         |            not |       ! |
  |                |         |         not_eq |      != |
  +----------------+---------+----------------+---------+

Комментарии не могут быть вложенными. /* начинает комментарий, */ заканчивает,
сколько бы блоков /* не было начато.

Числовые литералы: 49.625 == 0xC.68p+2.
Числа с плавающей точкой можно разделять с помощью '. Также они могут быть
в hex форме, но не в oct форме. 010.10f - десятичный литерал.

Тип ASCII и UTF-8 строковых литералов - "массив из N const char". N - размер
с учётом \0 и имеющий статическое время жизни.

Базовые принципы:
Сущность - значение, объект, ссылка, структурная привязка (auto [a, b]),
функция, перечисление, тип, член класса, битовые поля, шаблон, специализация
шаблона, пространство имён или пак параметров.

Имя - инентификатор, operator-function-id (operator+), определённые пользова-
телем литералы, conversion-function-id (operator T), template-id (имя шаблона
с списком аргументов, f<1, 2, 3>).

Каждое имя, описывающее сущность - объявление. Каждое имя представленное
goto-меткой - labeled-statement.

Локальная сущность - переменная с автоматическим временим жизни, структурная
привязка или *this.

Всякий раз, когда встречается имя - необходимо определить, не является ли это
специализацией шаблона. Такой процесс называется name lookup.

Одно и то же имя в разных единицах трансляции может указывать на один и тот
же объект из-за своей линковки.

Пользовательские типы вольны создавать несколько функций по умолчанию:
1) к-тор копирования/перемещения
2) присваивающий оператор копирования/перемещения
3) д-тор

Таким образом,

struct C {
  std::string s;
};

на самом деле выглядит как

struct C {
  std::string s;
  C() : s() {}
  C(const C& x) : s(x.s) {}
  C(C&& x) : s(static_cast<std::string&&>(x.s)) {}
        // : s(std::move(x.s)) {}
  C& operator=(const C& x) { s = x.s; return *this; }
  C& operator=(C&& x) { s = static_cast<std::string&&>(x.s); return *this; }
                   // { s = std::move(x.s); return  *this; }
  ~C() {}
};

One definition rule - юнит трансляции не должен иметь более одного определения
переменной, функции, класса, перечисления или шаблона.

struct X { static const int x = 0 };
const int& f(const int& r);
int n = b ? (1, X::x)   // X::x is not ODR-used
          : f(X::x);    // X::x is ODR-used, definition required

void f(int n) {
  [] { n = 1; } // not ODR-usable
  struct A {
  	void f() { n = 2; } // not ODR-usable
  };
  void g(int = n); // not ODR-usable
  [&] { [n] { return n; }; }; // OK
}

Только одного неполного определения типа достаточно, чтобы не писать его
в будущем. При условии, что X выше не был определён:

struct X;
struct X* x1; // OK
X* x2; // OK

Когда нужно полное определение типа:
   1) Определён Объект типа T.
   2) Определён е статический член класса типа T.
   3) T используется как аргумент функции new.
   4) Определено &-к-&& преобразование для типа T.
   5) Выражение явно приводится к типу T.
   6) При преобразовании из const/volatile void* к T* с помощью
      static_cast или dynamic_cast.
   7) Определён оператор доступа к членам класса типа T.
   8) T применяется как аргумент функций sizeof или typeid.
   9) Определена или вызвана фунцкия возвращающая тип T.
  10) Определён унаследованный от T класс.
  11) Присваивается lvalue типа T.
  12) T используется в alignof выражении.
  13) Exception-declaration типа T, T& или T*.

Скоупы:

Внутреннее определение j никак не влияет на внешнее определение j:
  int j = 24;
  int main() {
    int i = j, j;
    j = 42;
  }

Переменная во внутренней области инициализируется переменной из внешней:
  unsigned char x = 12;
  { unsigned char x = x; }

Массив из двух элементов:
  const int i = 2;
  { int i[i]; }

Инициализация перечислимого значения x равного 12:
  const int x = 12;
  { enum { x = x }; }

Размер массива проинициализирован значением перечисления:
  struct X {
  	enum e { z = 16 };
  	int b[X::z]; // OK
  };
  Имеется доступ к z, так как enum не использует слова struct/class.

Разрешение типа шаблона:
  typedef unsigned char T;
  template <
    typename T = T, // T справа - алиас на unsigned char
           T N = 0
  > struct X {};

Поиск имён происходит от самого вложенного блока до самого внешнего по отно-
шению к месту обращения к имени.

Программа состоит из юнитов трансляции, слинкованных вместе. Юнит трансляции
состоит из последовательности объявлений.
Виды линковки:
  внешняя      - разные сущности (переменные, классы и т.д) в разных юнитах
                 трансляции могут ссылаться на один и тот же объект.
  внутренняя   - разные сущности (переменные, классы и т.д) в одном юните
                 трансляции могут ссылаться на один и тот же объект.
  без линковки - нельзя получить доступ к сущности из других скоупов в том же
                 юните трансляции.

Безымянное пространство имён имеет внутреннюю линковку. Все остальные про-
странства имён имеют внешнюю линковку.

Базовая единица измерения памяти в С++ - байт (8 бит). Каждый байт имеет
уникальный адрес.

Время жизни может быть:
  static storage duration
    Все переменные, не имеющие dynamic, thread или не локальны, имеют
    статическое время жизни. Объекты с таким временем жизни будут жить до
    конца исполнения программы.
  thread storage duration
    thread_local переменные имеют thread storage duration. Память выделенная
    под такой объект должна существовать до конца жизни потока, в котором
    она была веделена. Такая переменная должна быть проинициализирована
    перед первым ODR-использованием, и разрушена при смерти потока.
  automatic storage duration
    Блочные переменные, не объявленные как static, thread_local или extern
    имеют автоматическое время жизни. Они живут до тех пор, пока поток
    выполнения не дойдёт до конца блока.
  dynamic storage duration
    Все объекты, созданные с помощью new и которые должны быть удалены с
    помощью delete.

Объектная модель
Языковые конструкции в С++ манипулируют объектами. Эти объекты занимают
определённое количество памяти во время своего создания, времени жизни
и разрушения (выполнения функции-деструктора). Важно: функция -- не объект,
поскольку она не занимает места в памяти тем способом, как это делает
объект. Объекты имеют типы, которые создаются реализацией.

Я не понимаю это UB.
struct X { const int n; };
union U { X x; float f; };
void tong() {
  U u = {{ 1 }};
  u.f = 5.f; // OK, creates new subobject of u (12.3)
  X *p = new (&u.x) X {2}; // OK, creates new subobject of u
  assert(p->n == 2); // OK
  assert(*std::launder(&u.x.n) == 2); // OK
  assert(u.x.n == 2); // undefined behavior, u.x does not name new subobject
}

Первый вложенный объект ВСЕГДА имеет такой же адрес, как и класс, в который
он вложен:
  struct X { int val = 0; };
  
  int main() {
  	X x;
  	assert(static_cast<void *>(&x) ==
  	       static_cast<void *>(&x.val)); // Всегда true.
  }
А также
  static const char first  = 'x';
  static const char second = 'x';
  assert(&first != &second); // Всегда true.

Деструктор может быть вызван явно.
  struct X {
    ~X() {}
  };

  X x; x.~X();

Удаление объекта с не-тривиальным деструктором путём преобразования к void *
не определено.
  struct X { ~X() {} };
  delete static_cast<void *>(new X); // UB, деструктор не вызовется.

struct C ...
const C& C::operator=(const C& other) {
  if (this != &other) {
    this->~C();          // Время жизни *this заканчивается.
    new (this) C(other); // Новый объект типа C.
    f();                 // Well-defined.
  }
  return *this;
}

Placement new позволяет создавать const-объекты.

  struct A{ void f() const {} };
  struct B{} const b;
  new ((void *)(&b)) const A;
  reinterpret_cast<const A *>(&b)->f();
  
Операторы new и delete могут быть переопределены следующим способом:  
  [[nodiscard]] void *operator new(std::size_t size) {
    return std::malloc(size);
  }
  void operator delete(void *pointer) {
    std::free(pointer);
  }
  void operator delete(void *pointer, std::size_t) {
    std::free(pointer);
  }
Теперь вместо определённых в STL операторов new, delete будут вызываться эти.
ВАЖНО: хоть и использование всех операторов new, delete без заголовочного
файла <new> well-formed, использование типов std::size_t и std::align_val_t,
использующихся в этих операторах требует включения соответствующих заголовков
(<cstddef>, <new>).

Семантика аллоцирующих функций
  Эти функции должны быть объявлены как свободные, либо как методы класса.
  Нельзя объявлять их в пространствах имён, помимо глобального (::). Эта
  функция может быть шаблонной (файл template_allocation_function.cpp).

Можно устанавливать обработчики вызовов new, когда они проваливаются, с
помощью std::set_new_handler (файл new_handler.cpp).

Функции аллокации/деаллокации могут быть вызваны с параметром
std::align_val_t, который говорит, с каким выравниванием должен быть
аллоцирован блок памяти (файл align_allocation.cpp).

operator delete может принимать nullptr и должен корректно его обрабатывать
(ничего не делать).

Выравнивание - способ размещения объекта в памяти; характеризуется кол-вом
байт между адресами, на которых может быть аллоцирован объект.

Пример:
  alignas(128) struct X { int i; };
  размещается в памяти так:
  x1                x2                x3
  |_______________| |_______________| |_______________|
  128 байт          128 байт          128 байт

Каждое значение выравнивания в alignas должно быть степенью двойки
(4, 8, 16)...

Тривиально копируемые типы могут быть безопасно помещены в массив char,
unsigned char или std::byte, а также скопированы с помощью memcpy.

cv void может выступать в операторе ?: (2 и 3 операнды), в операторах typeid,
noexcept и decltype, и как выражение в return.

CV-модификаторы
  const T -- неизменяемый объект типа T;
  volatile T -- изменяемый объект T или const volatile T;
  const volatile T -- неизменяемый объект, полученный из volatile T, или
    изменяемый объект, полученный из const T.

Пример в файле const_volatile.cpp.

6.8 Program execution
