HTTP требует открытые методы и хедеры для передачи смысла
запроса. В нём содержится URL, URI или URN.

Базовые понятия:
прокси:
	Промежуточная программа, являющаяся одновременно и
	клиентом, и сервером. "Прозрачный" прокси не модифицирует
	запрос или ответ. "Не прозрачный" прокси наоборот,
	модифицирует (сокращение протокола, анонимные операции, ...).

шлюз:
	Сервер, являющийся посредником для другого сервера. В отличие
	от прокси, шлюз передаёт в точности такой же запрос и клиент
	может не знать, что общается со шлюзом, а не настоящим
	сервером.

тоннель:
	Программа, действующая как слепое реле между двумя
	соединениями. Туннель перестаёт существовать когда
	оба конца соединения закрываются.

Firewall | Brandmauer:
	Элемент компьютерной сети, фильтрующий входящий траффик
	в соответствии с заданными правилами.

HTTP-запрос может передаваться через посредников, образуя
цепь из соединений (При большой дальности сигнала, например).

Любая часть цепного соединения может иметь кэш, что позволяет
обрывать соединение раньше времени в целях экономии времени
и ресурсов, если запрос был найден в кэшах промежуточного сервера.

Обычно HTTP-соединение происходит по TCP 80 порту, но также можно
использовать и другие порты.

HTTP может быть реализован поверх любого другого сетевого
протокола.

HTTP/1.0 каждый раз открывает соединение для запроса, в то время
как HTTP/1.1 может использовать одно открытое соединение для
нескольких запросов.

HTTP не устанавливает лимит на длину URI. Сервер должен вернуть
ошибку 414, если он не в состоянии обработать URI такой длины.

Схема HTTP URL:
	"http:" "//" host [ ":" port ] [ abs_path [ "?" query ] ]

Если порт не указан, по умолчанию задаётся 80 порт.

Если символ в URI не входит в "reserved" или "unsafe" множества,
он заменяется на "%" HEX HEX.

После домена можно ставить ":": https://www.example.com:

Форматы времени:
  Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
  Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
  Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format

Первый вариант предпочтителен, но сервер должен уметь обрабатывать
все 3 формата.

Часовой пояс всех дат должен быть установлен по Гринвичу.

сontent-coding:
Устанавливает способ кодирования сообщения с целью уменьшения
размера для передачи. Сообщение может кодироваться с помощью:
    gzip       - GNU zip
    compress   - Unix files compression (./compress)
    deflate    - zlib
    identity   - no transformations

content-coding используется в полях Accept-Encoding и
Content-Encoding.

Значения content-coding независимы к регистру.
Значения transfer-coding независимы к регистру.

Если указано неверное значение transfer-coding, сервер должен
вернуть ошибку 501 (Unimplemented) и закрыть соединение.
Сервер не должен отправлять transfer-coding клиенту.

Передача участками осуществляется с помощью Chunked-Body.
Кодирование по участкам завершается чанком с длиной 0, а затем
завершителем с оставшимися данными, заканчивающихся
пустой строкой.

Content-Type: text в канонической формедолжен использовать CRLF
как перенос строки внутри текста. Однако чаще всего используются
переносы CR или LF отдельно.

multipart: Эпилог каждого сообщения должен быть пустым. Если 
клиент получает неизвесный подтип multipart, он воспринимается
как multipart/mixed.

Если не хватает предоставленных стандартом заголовков, можно
определять свои. Обычно им добавляют префикс "X-" для избежания
конфликтов имён. Но некоторые добавляют иные префиксы.

range-unit: По умолчанию установлено в "bytes", но при желании
это значение можно изменить. Оно представляет то, в чём измеряется
размер сообщения.

HTTP-сообщение состоит из стартовой строки, 0-* хедеров, пустая
строка (CRLF - индикатор конца хедеров), и само сообщение
(опционально).

Каждое поле хедера предпочтительно должно записываться как:
Header: Field
1 пробел после названия хедера предпочтителен, хоть и может
использоваться любое их количество.

Присутствие сообщения сигнализируется присутствием полей
Content-Length или Content-Encoding в хедерах запроса. Если
сообщение было получено с Transfer-Encoding и Content-Length,
последнее должно быть проигнорировано.

Если сообщение включает transfer-coding НЕ установленый в
identity, Content-Length должен быть проигнорирован.

Неизвестным заголовкам следует быть проигнорированными на стороне
клиента, но прокси должен передать их в исходном виде.

Если при передаче медиа не указан Content-Type, клиент может
либо попытаться угадать тип по расширению файла, либо (что более
предпочтительно), воспринять его как "application/octet-stream".

HTTP позволяет слать несколько запросов очередью, не дожидаясь
ответа на каждое из них, а ожидая получить сразу несколько. К тому
же, не тратится время на многочисленные "рукопожатия". Таким
образом TCP-сессия используется гораздо более эффективно.

Клиентам не следует применять такие пайплайны при работе с
не идемпотентными запросами.

Методы:
OPTIONS:
    Представляет собой способ получения информации о доступных
    вариантах связи. Позволяет узнать требования сервера или
    другую информацию не подразумевая действия над ресурсом,
    такие как извлечение. Ответы к таким запросам не кэшируются.
    Если OPTIONS запрос имеет тело, должен быть установлен
    Content-Length или Transfer-Encoding. Хоть и HTTP/1.1 не
    подразумевает работы с телом сообщения, это может быть
    реализовано в будущем.
    OPTIONS * позволяет получить все свойства сервера, а так же
    используется как "пингование" ресурса чтобы узнать, доступен
    ли он. Если тела сообщения в ответе нет, Content-Length
    должен быть установлен в "0". Если OPTIONS передаётся через
    прокси, прокси должен проверить наличие хедера "Max-Forwards",
    если его значение равно "0", прокси не должен осуществлять
    передачу запроса.

GET:
    Получить информацию с сервера. Семантика GET запроса переходит
    в "Условный GET" если заголовок запроса включает в себя
    условные поля: "If-*".

    Условный GET:
        Требует чтобы запрос был осуществлён только при
        выполненном условии "If-*" заголовков.

    Частичный GET:
        Нужен для уменьшения загрузки сети, позволяет завершить
        получение ресурса без передачи данных уже находящихся у
        клиента.

HEAD:
    Идентичен GET, только ответ не должен содержать тело
    сообщения. Нужен для получения метаинформации о ресурсе,
    например проверка, является ли запрашиваемый ресурс доступным,
    его время создания и т.д.

POST:
    Используется для передачи информации серверу, с целью,
    например, размещения её там. Если ресурс был создан, приходит
    ответ 201 (Created), а так же хедер "Location", указывающий
    на местоположение созданного ресурса.

PUT:
    PUT запрашивает чтобы объект был сохранён под переданным URI.
    Если по указанному URI уже находится какой-то ресурс, новые
    данные должны быть восприняты как обновлённая версия старых 
    данных. Если ресурс был создан, приходит ответ 201 (Created),
    или 204 (No Content).
    Ключевое отличие PUT и POST заключается в восприятии URI.
    URI в POST запросе воспринимается как путь к ресурсу, который
    будет обрабатывать закрытый в себе объект.
    URI в PUT запросе воспринимается как непосредственный путь
    к объекту и сервер не должен пытаться применить этот же
    запроc к другому ресурсу.

DELETE:
    Удаляет ресурс с сервера находящийся по указанному URI.

TRACE:
    Возвращает полученный запрос так, что клиент может увидеть,
    какую информацию промежуточные серверы добавляют или изменяют
    в запросе.

CONNECT:
    Преобразует соединение в прозрачный TCP/IP-туннель.

Согласование контента.

Данные на сервере называются ресурсом. Клиент в праве запросить
одни и те же данные в разных видах (text, json, xml, html и т.д).
Каждый вариант называется представлением, при этом каждое
представление имеет свой URL. Выбор содержимого определяется
механизмом согласования контента.
Варианты согласования контента:
На стороне клиента:
    Клиент передаёт конкретные заголовки, такие как Content-Type.

На стороне сервера:
    Сервер возвращает коды
        300 (Multiple Choices),
        406 (Not Acceptable)

Если точного соответствия того представления, что выбрал клиент
не существует, выбирается более подходящее. Например по алгоритму
согласования от Apache:
https://httpd.apache.org/docs/2.2/en/content-negotiation.html#algorithm.

Кэши
От использования кэшей не будет смысла, если они не будут
существенно улучшать производительность.

Хедеры:
Accept
    Установить конкретный тип медиа, разрешённый в ответе.
    "*" означает группировку всех типов в заданной группе.
    Например "*/*" означает все типы, "type/*" все подтипы типа
    "type". За этим можед идти параметр "q", означающий качество
    от 0 до 1.
    Пример: "Accept: audio/*; q=0.2, audio/basic", что примерно
    означает "Я хочу ответ типа audio/basic, пришлите мне любой
    тип аудио если он станет лучшим из имеющихся после снижения
    качества на 80%". Если Accept не указан, сервер предполагает,
    что клиент соглашается на любой тип медиа-контента ("*/*").

Accept-Charset
    Установить желаемую кодировку ответа. "*" означает любую
    кодировку.

Accept-Encoding
    Установить кодирование сообщения. Если указан Accept-Encoding:
    *, выбирается кодирование с наивысшим параметром q отличным от
    0. Параметр "identity" принимается всегда при q != 0.

Accept-Language
    Установить язык сообщения. Можно применять параметр q для
    выбора приоритета. Например:
    Accept-Language: da, en-gb;q=0.8, en;q=0.7,
    что означает:
    "Я бы хотел датский, но также можно и британский английский,
    в ином случае английский".

Accept-Ranges
    Указать принимаемую единицу измерения информации. Единственная
    принятая в HTTP/1.1 - bytes.

Age
    Передать количество времени, прошедшего с момента создания
    или редактирования ресурса. Если кэш получает поле Age
    превышающее границу 32-битного числа, он должен срезать его
    до 2147483648 (2^31).
    
Allow
    Установить принимаемые методы. Например Allow: GET, POST.
    Цель этого заголовка - проинформировать клиента о доступных
    методах сервера. Allow должен присутствовать в ответе 405
    (Method Not Allowed).

Authorization
    Клиент, желающий авторизовать себя на сервере должен передать
    этот заголовок. Значение Authorization состоит из информации,
    необходимой для авторизации.

Cache-Control
    Определяет, какое время ресурс должен находиться в кэше, а
    также метод его кэширования.
    Параметр "max-age" отвечает непосредственно за передачу
    времени нахождения файла в кэше. Кэширование может быть 3
    типов: public, private, no-store.

    public:
        Любой клиент может осуществлять кэширование на любом
        уровне.

    private:
        Ресурс предназначен только для конкретного пользователя.

    no-store:
        Самый строгий метод кэширования. Кэшироваться не должны
        ни части запроса, ни части ответа.

Connection
    Указывает что делать после выполнения запроса. По умолчанию
    установлено "Connection: close".

Content-Length
    Указывает длину принимаемого сообщения в байтах.

Content-Location
    Указывает альтернативное расположение сущности.

Content-MD5
    base64 от MD5 хеша запрашиваемой сущности для проверки
    целостности.

Content-Range
    Байтовый диапазон передаваймой сущности. Нужен для частичного
    GET.

Date
    Определяет время в которое сообщение было создано.

ETag
    Уникальный идентификатор сущности используемый при
    кешировании.

Expect
    Указать серверу дополнительные действия, например
    Expect: 100-continue.

Expires
    Дата предполагаемого истечения срока актуальности сущности.
    Expires: Tue, 31 Jan 2012 15:02:53 GMT

From
    Адрес эл. почты клиента.
