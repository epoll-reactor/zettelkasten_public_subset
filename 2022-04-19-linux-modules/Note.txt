Модуль Linux - кусочек кода, который может быть загружен в/выгружен из ядра во время его работы. Они призваны
расширить функциональность ядра без перезагрузки. Например, драйвера являются модулями ядра, получающими доступ
к "железу". Без модулей же, этот вопрос бы решался только полной пересборкой монолитного ядра с нужным
функционалом.

Наблюдение
  заголовочные файлы в <linux/...> содержат относительно немного информации. Основной используемый код находится
  в ядре.

Утилиты modprobe, insmod и remmod доступны
  в Debian/Ubuntu:    build-essential, kmod
  в Arch Linux:       gcc, kmod

Чтобы посмотреть список загруженных модулей, достаточно ввести
  sudo lsmod.

Информация о них хранится в /proc/modules.

Модуль, скомпилированный под одно ядро, не запостится под другим без опции CONFIG_MODVERSIONS в ядре, однако,
большинство дистрибутивов содержат ядра с этой включенной опцией. Далее версионирование не будет рассмотрено
так детально, поэтому этот момент можно опустить.

Далее нужны заголовочные файлы, которые можно получить так:
  Debian/Ubuntu -     apt-cache search linux-headers-`uname -r`
  Arch Linux    -     sudo pacman -S linux-headers

Следует заглянуть в hello-world-module.
Если не установлено переменной PWD := $(CURDIR) в Makefile, модуль не соберётся с sudo make.

Посмотреть информацию о модуле
  modinfo hello-1.ko

Загрузить модуль
  sudo insmod hello-1.ko

Выгрузить модуль
  sudo remmod hello-1.ko

Посмотреть, загрузился ли модуль
  sudo lsmod | grep hello

Посмотреть лог
  sudo journalctl --since "1 hour ago" | grep kernel
| sudo dmesg -c

Модуль обязан иметь по крайней мере 2 функции: init_module(), которая вызывается при insmod, и cleanup_module(),
вызываемая при rmmod. Вообще, с версии 2.3.13, всё изменилось, и для модулей можно использовать функции с любыми
именами.

Модули всегда должны включать <linux/module.h> и могут включать <linux/kernel.h> (в hello world модуле оттуда
используется функция вывода pr_alert()).

Важные замечания по кодстайлу
1) Всегда используются табы вместо пробелов. Таков стиль написания в ядре.
2) Вместо printk(KERN_INFO ...) и так далее, принято использовать макросы pr_info, pr_warn и т.д, во избежаниe
лишних ударов по клавиатуре.
3) Модули ядра компилируются немного иначе, чем обычные приложения. Сейчас принято писать простые Makefile'ы,
   использующие какой-то бэкенд (утилиту kbuild, M=$PWD указывает, где расположен файл kbuild).

Упражнение
  Возвращаемое значение в init_module() было изменено с 0 на -1. Вследствие, после сборки, при попытке запустить
  модуль, Linux сказал, что у меня нет на это прав.

Наблюдение
  Название объектного файла не может носить имя module.o (следовательно, и исходный код в module.c),
  потому что это имя уже используется.

Если же мы имеем несколько модулей, мы добавляем их таким способом
  obj-m += module-1.o
  obj-m += module-2.o

Реальный пример Makefile с множеством модулей
  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/char/Makefile.
  Здесь obj-$(CONFIG_FOO) раскрывается в obj-m или obj-y.

__init и __exit.
__init говорит ядру вызвать функцию-инициализатор и выгрузить её из памяти при завершении в встроенных
дравйверах, но не в загружаемых модулях.
Существует также макрос __initdata, похожий на __init, но он предназначен скорее для переменных.
__exit говорит ядру выбросить функцию, когда модуль был загружен в ядро. Опять же, так же, как __init, имеет
место только для драйверов, но не для загружаемых модулей.

Замечание
  Модули могут быть без exit-функции, если они этого не подразумевают.

Лицензии описаны в https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h.
Для указания лицении, которую мы намерены применять, используется MODULE_LICENSE.
Например
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("epoll-reactor");
  MODULE_DESCRIPTION("Вишенка");

Аргументы командной строки
Модули поддерживают аргументы командной строки, но не привычным способом наподобие int argc, char *argv[].
Для этого служит макрос module_param().
Передача параметров осуществляется посредством insmod, например
  insmod mymodule.ko myvariable=5.
Переменные-аргументы и соответствующие макросы должны быть размещены в начале программы для ясности.
Примеры
  int my_int;
  module_param(my_int, int, 0);

  int my_array[2];
  module_param_array(my_array, int, NULL, 0); // Не интересует размер.

  short my_array[4];
  int count;
  module_param_array(my_array, short, &count, 0); // Записать кол-во аргументов в count.

Модули в нескольких файлах
Пример Makefile, собирающего несколько *.c файлов в один модуль
  obj-m += begin.o                    // Файл 1.
  obj-m += end.o                      // Файл 2.
  obj-m += begin_end.o                // Конечный таргет.
  begin_end-objs += begin.o end.o     // Промежуточный таргет (именно с -objs в конце).
  
  PWD := $(CURDIR)
  
  all:
  	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
  
  clean:
  	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
  
Force-выгрузка модуля
  sudo rmmod -f module

Наблюдение
  При разделении модуля на файлы (директория splitted-into-files-module в этом документе),
  modinfo показывает две лицении, если она была установлена в каждом из двух файлов.

Запуск и остановка модулей
Программы обычно запускаются в функции main(), но модули работают немного иначе. Их входным пунктом является
функция, переданная в module_init. После выполнения этой функции, ядро более ничего не делает с модулем.
Все модули нуждаются также в функциях, переданных в module_exit. Они должны возвращать ядро в начальное
состояние до запуска модуля. 

Программисты на С используют, например, printf(), включая соответствующий заголовок, чтобы при линковке
компилятор нашёл код для printf() в libc и мог выполнить его.
В ядре же дела обстоят иначе. В "Hello, world" примере можно видеть вызов pr_info (printk) без включения
какого-либо I/O-заголовка. Причина в том, что модули -- объектные файлы, чьи символы разрешаются во время
запуска insmod или modprobe. Определения символов находятся непосредственно в ядре.
Список символов в ядре можно увидеть в /proc/kallsyms.

Просмотр системных вызовов, выполняемых кодом
  strace ./binary

User / Kernel space
Ядро в общем решает вопрос доступа к ресурсам. Программы могут конкурировать за общий ресурс, и ядро
призвано правильно обрабатывать такие ситуации. По этой причине, ЦПУ может работать в нескольких режимах,
каждый из которых даёт разный уровень свободы действий в системе. Unix имеет 2 уровня (rings) --
ring 0, известный как "supervisor mode", когда разрешено делать всё, и более низкий в правах ring 1,
известный как "user mode".

При вызове функций в libc, мы выполняем их в режиме пользователя, но они могут переходить в режим ядра.

Code space
Что случается, когда Linux посылает SIGSEGV? Именно то, что мы ожидаем -- указатель не указывает на
реальную память. Когда запускается процесс, ядро резервирует некоторое количество памяти для него, куда он
размещает стек, кучу и прочие вещи. Эта память начинается с адреса 0x00000000. Поскольку адресные пространства
процессов не пересекаются, через, например, 0xbffff978 можно определённо получить доступ к ячейке памяти в ОЗУ.
Поэтому процесс не может получить доступ к адресам другого процесса (хотя, ядро предоставляет такую возможность).

Ядро имеет своё адресное пространство, и поскольку модуль это код, динамически загружающийся и выгружающийся в
него -- он разделяет адресное пространство ядра. Поэтому, если модуль падает, падает и ядро.

В микроядрах же, модули имеют своё адресное пространство.

Драйвера.
Драйвера это модули ядра, предоставляющие интерфейс взаимодействия с аппаратной частью. В UNIX, каждый
аппаратный элемент (ОЗУ, сетевые устройства, ...) представлены файлом в /dev, взаимодействуя с которым, можно
взаимодействовать с аппаратной частью. Например, драйвер es1370.ko позволяет соединить файл /dev/sound с
звуковой картой Ensoniq IS1370. User-space программы использут /dev/sound, не имея понятия, какой драйвер сейчас
установлен.

Рассмотрим вывод
  $ ls -l /dev/hda[1-3]
  brw-rw---- 1 root disk 3, 1 Jul 5 2000 /dev/hda1
  brw-rw---- 1 root disk 3, 2 Jul 5 2000 /dev/hda2
  brw-rw---- 1 root disk 3, 3 Jul 5 2000 /dev/hda3
"3, {1,2,3}" - пары чисел, где первое число - главное (major), второе - второстепенное (minor). Мажорное число
говорит нам о том, какой драйвер используется. Все устройства с одинаковым мажорным числом используют один и
тот же драйвер. Минорное же число используется для отличия устройств между собой (индексации, может быть).

Устройства разделены на 2 группы: блочные и символьные.
Суть блочных устройств в том, что они могут буферизовать вывод (устройства ввода/вывода). Блочные устройства
могут только принять входные данные и отдать выходные. Символьные же устройства могут использовать столько памяти,
сколько им понадобится.
Первая буква в выводе ls -l говорит, блочное ли (d) или символьное (c) устройство перед нами.

Создание устройства coffee с major/minor числами 12 и 2
  mknod /dev/coffee c 12 2
  
Замечание
  Не стоит распологать устройства, созданные для тестов и прочего в /dev. Однако при написании драйверов,
  в установочных скриптах, конечно, нужно указывать /dev.

Когда мы получаем доступ к устройству, ядро определяет, какой драйвер нужно использовать для обработки запроса
на основе мажорного числа. О минорном же числе ему знать не нужно, оно нужно только самому драйверу.

Код драйверов определяет работу со структурой file_operations
(https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h).
Однако, драйверу не всегда нужны все поддерживаемые операции (указатели на функции), поэтому неиспользуемые
функции устанавливаются как NULL.
Пример звукового драйвера, реализовывающего лишь пару операций
  struct file_operations fops = {
    .read    = device_read,
    .write   = device_write,
    .open    = device_open,
    .release = device_release
  };
Всем неуказанным указателям в этом инициализаторе GCC присваивает NULL.

Каждое устройство представлено в ядре как файловая структура,
  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h.
Файл - внутренняя структура ядра и никогда не должна появляться в user-space программе. Это не то же, что FILE,
определённый внутри glibc.
Этот файл описывает открытый файл, а не файл на диске в целом (его описывает inode).

Добавление драйвера означает регистрацию его в ядре. Это делается с помощью функции
 int register_chrdev(
     unsigned int            major, // Мажорное число, которое мы хотим зарегистрировать.
                                    // Минорное число не нужно ядру, только драйверу.
     const char             *name,  // Имя устройства (их можно найти в /proc/devices).
     struct file_operations *fops   // Указатель на file_operations нашего драйвера.
 );
 // Негативное возвращаемое значение означает неудачу регистрации.
 // Если в major передать 0, функция вернёт номер, представляющий динамически созданное мажорное число.

Более новый интерфейс регистрации символьных устройств подразумевает 2 этапа. Сначала нужно создать диапазон
номеров устройств, которые могут быть заполнены с помощью
  int register_chrdev_region(dev_t from, unsigned count, const char *name);
  или
  int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);

Далее следует создать структуру cdev для символьного устройства, связанную с номером устройства.
  struct cdev *my_cdev = cdev_alloc();
  my_cdev->ops = &my_fops;

Однако, лучше использовать cdev_init
  void cdev_init(struct cdev *cdev, const struct file_operations *fops);

После инициализации, можно добавлять устройство с помощью
  int cdev_add(struct cdev *p, dev_t dev, unsigned count);

Удаление устройств из ядра
  Нельзя просто так rmmod'уть модуль, когда нам захочется. Если файл устройства открыт процессом и в этот момент
  мы удаляем модуль, используя файл, мы обратимся в память, где раньше была функция чтения/записи модуля. Если
  нам повезёт, мы получим уродливое сообщение об ошибке. Иначе же, мы попадём в адресное пространство другого
  модуля, что означает прыжок в середину другой функции внутри ядра. Результат этого невозможно предсказать, но
  он не будет сильно оптимистичным.

Третья колонка в /proc/modules указывает, сколькими процессами в данный момент используется модуль. Если это
число не равно 0, rmmod провалится. Управление этими числами ведётся функциями в
  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h
  try_module_get(THIS_MODULE)    - Увеличить счётчик.
  module_put(THIS_MODULE)        - Уменьшить счётчик.
  module_refcount(THIS_MODULE)   - Получить значение.

Написание модулей для разных версий ядра
Между версиями ядра существуют отличия в API, поэтому может возникнуть необходимость поддержки нескольких версий
кода. Сделать это можно, сравнив макросы LINUX_VERSION_CODE и KERNEL_VERSION. В версии a.b.c, значения этих
макросов будут равны 2^16a + 2^8b + c.

Файловая система /proc служит для отправки информации от модулей к процессам. Изначально задумывалась как средство
лёгкого доступа к информации о процессах (откуда и название /proc).
Procfs находится в ОЗУ.

Inode (index-node) это указатель на место, где находится файл на диске. Inode содержат информацию о файле,
например, помимо указателя, разрешения файла или путь к нему.

proc_fops
Эта структура определена с версий ядер 5.6+ в
  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/proc_fs.h.
Раньше же вместо proc_fops использовался file_operations. Но, поскольку некоторые его члены не нужны procfs,
использование file_operations раздувало размер кода, работающего с procfs, а также уменьшало производительность.

Из proc-файлов можно как читать (пример procfs-file в этом документе), так и писать (read-write-procfs-file).

Причина сущестсования copy_from_user и get_user в том, что память ядра организована сегментами. Это значит, что
указатель указывает не на уникальное место в памяти, а на место в сегменте, и нам нужно знать, какой сегмент
может использовать эту память. Существует один сегмент памяти для ядра, и по одному для каждого из процессов.
Процесс имеет доступ только к своему сегменту, поэтому, не приходится думать об этом во время написания user-space
кода.
Put_user и get_user используются для работы с одним символом, copy_to_user и copy_from_user -- с несколькими.

Было показано, как работать с /proc-файлами через /proc-интерфейс. Однако, можно делать это с помощью inod'.
Главная причина для этого - использование дополнительных функций, например, разрешений на файл.

Как можно было убедиться раньше, запись и чтение /proc-файлов немного "сложное". Поэтому существует API под
названием seq_file, состоящий из 3 функций: start(), next() и stop().
Всё начинается с вызова start(), если эта функция вернула не-NULL значение, вызывается next(). next() - итератор,
и при каждом его вызове, вызывается также функция show(). Она записывает введённые пользователем данные в буфер.
next() вызывается, пока она не вернёт NULL. Когда это произошло, вызывается stop().

sysfs
sysfs позволяет взаимодействовать ядром через файлы; писать или читать данные внутри модулей.

Файлы устройств призваны представлять их же. Многие устройства используются как для ввода, так и для вывода,
поэтому в ядре должен быть механизм, позволящим получать выходные данные из процессов и отправлять их
устройствам. Это реализовано открытием файла устройства для чтения/записи.

Для таких целей служит функция ioctl (Input/Output ConTroL). Каждое устройство может иметь свои ioctl-команды (
write ioctl, read ioctl). 

Замечание
  В file_operations можно установить ioctl-функцию двумя способами, через unlocked_ioctl и compat_ioctl.
  unlocked_ioctl был создан по той причине, что обычный вызов ioctl блокирует всё ядро, пока он не завершится,
  в то время как unlocked_ioctl - нет. compat_ioctl же нужен для использования 32-битным пользовательским кодом
  системных вызовов 64-битного ядра.

Чтобы избежать возможности потери файлов, можно запустить команду sync. Она запишет на диск все данные,
находящиеся в буфере ввода/вывода у ядра.

В целом, процесс не может получить доступ к ядру непосредственно. Он не может заглянуть в память ядра или вызвать
его функции. Однако, системные вызовы являются исключением. Это происходит так: процесс заполняет соответствующие
системному вызову регистры и затем вызывает специальную инструкцию, которая делает прыжок на прежде установленное
место в памяти ядра (процесс может читать, но не может писать туда). На процессорах Intel это делается прерыва-
нием 0x80. После этого момента ЦПУ знает, что вы больше не выполняете код от имени пользователя, только от имени
ядра. И после этого мы можем делать всё, что нам нужно.
Место, куда процесс осуществляет прыжок называется system_call. Функция в этой локации проверяет номер системного
вызова. Позже, ядро обращается к таблице системных вызовов (sys_call_table), чтобы получить адрес нужной функции.
Затем эта функция вызывается; после завершения, управление снова отдаётся процессу (или другому процессу, если
текущий завершился).

В книге написано, что существует возможность изменить sys_call_table, подставив туда свои функции, замещяющие
стандартные системные вызовы, но эта возможность использовалась лишь малварью, из-за чего была удалена.
Сейчас же символ sys_call_table убран из доступных символов ядра, чтобы предотвратить потенциально зловредное
использование.

Вот так можно заменить существующий модуль
  $ sudo grep sys_call_table /proc/kallsyms
  ffffffffacc01440 D sys_call_table
  ffffffffacc02560 D ia32_sys_call_table
  $ sudo insmod syscall.ko sym=0xffffffffacc01440

Примечание
  макрос asmlinkage реализован как #define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0))).
  Для функций на С, не вызываемых из ассемблерного кода, по умолчанию установлено соглашение о вызове
  cdecl (или fastcall, это не важно). Asmlinkage же нужен для передачи всех аргументов функции через стек.
  Дело в том, что в любом случае, при системном вызове, ядро должно сохранить значения всех регистров на стеке.

Существует возможность заменить оригинальные системные вызовы своими (пример syscall-spy). Дело состоит в том,
чтобы сохранить указатель на оригинальную функцию системного вызова, и далее вместо неё установить указатель на
свою функцию, делающую нужные нам вещи. Это прекрасный шанс очень легко угробить свою (или чужую) систему, или же
написать зловредный код.
В syscall-spy перезапись sys_open работает нормально, а write нет. После запуска модуля система зависает намертво
(лог ядра можно посмотреть в WriteSyscallDie.txt).

Что происходит, когда тебя просят о чём-то, когда ты занят? В худшем случае, можно сказать "Не сейчас, я занят;
проваливай!". Однако, в случае модуля ядра, можно "усыпить" процесс до тех пор, пока модуль не сможет его обрабо-
тать (процессы "засыпают" и "просыпаются" всё время -- благодаря этому и возможна работы системы с одним ядром).

Примечание
  Чтобы открыть файл и оставить его в открытом состоянии, можно использовать tail -f файл. Эта команда изменяет
  статус процесса на TASK_INTERRUPTIBLE. Это означает, что задача не будет выполнена до тех пор, пока она не
  проснётся. Затем, эта команда вызывает планировщик для переключения контекста на другой процесс.

Продолжить с 11.2 Completions (68 страница)
file:///home/krot/text/books/The%20Linux%20Kernel%20Module%20Programming%20Guide.pdf
