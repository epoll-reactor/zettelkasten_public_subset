Структуру компилятора можно описать так:
                      +---------------+
Исходная программа -> |   Компилятор  | -> Целевая программа
                      +---------------+

Результат его работы так:
                      +---------------+
Входные данные     -> |     Целевая   | -> Выходные данные
                      |   Программа   |
                      +---------------+

Формальное описание работы интерпретатора:
Исходная программа -> +---------------+
Входные  данные    -> | Интерпретатор | -> Выходные данные
                      +---------------+

Гибридный компилятор:
   Исходная программа
          |
          v
   +-------------+
   |  Транслятор |
   +-------------+
          |
          v
   Промежуточная программа -> +-------------+
         входные данные    -> | Виртуальная | -> Выходные данные
                              |   Машина    |
                              +-------------+

Компилятор должен быть организован как несколько независимых модулей.
Компилятор разделяется на три части:
  Front-end (analysis), разбивающий входную программу на токены, проверяя, образуют ли они коррект-
  ную грамматику. Выполняется проверка типов. Если программа не соответствует грамматике или содер-
  жит ошибки типов, формируется сообщение об ошибке на этой стадии, обычно указывая нахождение про-
  блемного места в коде (строка и колонка). Аспекты front-end включают в себя лексический, синтак-
  сический и семантический анализ, а так же управление таблицей символов. Front-end преобразует
  исходный текст в промежуточное представление, которое передаётся на стадию middle-end.

  Стадии front-end:
    Лексический анализ - разделяет исходный текст на токены (имя и опциональный атрибут).

    Синтаксический анализ - обычно строит дерево разбора опираясь на поток токенов, полученных
    этапом выше. Определяет, образуют ли входные данные грамматику языка.

    Семантический анализ - добавляет семантическую информацию в AST и строит таблицу символов, выпол-
    няет проверки типов и присваиваний.
      ???(таблица символов)
  
  Middle-end (optimizer), выполняющий архитектурно-(в смысле ЦПУ)-независимые оптимизации
  промежуточного представления. Полученное оптимизированное представление программы передаётся на
  стадию back-end.

  Стадии middle-end:
    Анализ - сбор информации из AST, data-flow анализ, построение use-define цепей и различные дру-
    гие проверки. Control flow graph (CFG) каждой функции и Call graph (граф вызовов) целой програм-
    мы строится на данном этапе.
      ???(use-define цепи)
      ???(CFG)
      ???(использование таблицы символов из предыдущего этапа)

    Оптимизация - преобразование промежуточного представления в функционально идентичные, но более
    эффективные формы. Примеры оптимизаций - удаление мёртвого или недостижимого кода, сворачивание
    констант (вычисление простых выражений типа 100 + 200 - 1), вынесение вычислений кода за пределы
    цикла, если это возможно и т.д (см. симлинк о оптимизациях).

  Back-end (synthesize), выполняющий архитектурно-(в смысле ЦПУ)-зависимые оптимизации и генерацию
  конечного кода.

  Стадии back-end:
    Машинно-зависимые оптимизации;
    Генерация машинно-зависимого кода.

Существуют однопроходные и многопроходные компиляторы. Однопроходный обычно быстрее выполняет свою
работу, но программа на таком языке лишается возможности например, как в С++, обращаться к перемен-
ной внутри класса на строке 10, когда она объявлена как член на строке 20. Многопроходный же компи-
лятор допускает это.

Простой пример компиляции:
          position = initial + rate * 60
                |
    +------------------------+
    | Лексический анализатор |
    +------------------------+
                |
<id, 1> <=> <id, 2> <+> <id, 3> <*> <60>
                |
   +---------------------------+
   | Синтаксический анализатор |
   +---------------------------+
                |
                =
               / \
              /   \
          <id, 1>  +
                  / \
                 /   \
             <id, 2>  *
                     / \
                    /   \
                <id, 3>  60

                |
   +---------------------------+
   | Семантический анализатор  |
   +---------------------------+
                |
                =
               / \
              /   \
          <id, 1>  +
                  / \
                 /   \
             <id, 2>  *
                     / \
                    /   \
                <id, 3> inttofloat
                         |
                        60

                |
   +---------------------------+
   | Генератор промеж. кода    |
   +---------------------------+
                |
      t1 = inttofloat(60)
      t2 = id3 * t1
      t3 = id2 + t2
      id1 = t3
                |
   +---------------------------+
   |     Оптимизатор кода      |
   +---------------------------+
                |
      t1 = id3 * 60.0
      id1 = id2 + t1
                |
   +---------------------------+
   |       Генератор кода      |
   +---------------------------+
                |
      LDF    R2, id3         # load floating point
      MUFL   R2, R2, #60.0   # multiply floating point
      LDF    R1, id2         # load floating point
      ADDF   R1, R1, R2      # add floating point 
      STF    id1, R1         # store floating point

