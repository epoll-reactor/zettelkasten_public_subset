Статическая инициализация в С++ обязана быть атомарной. Поэтому при такой инициализации
компилятор может вызвать рекурсивный мьютекс:
  void f() {
    static const int value = 1;
  },
  
и при таком случае тоже:
  void f(int n) {
    static const int value = n;
  },  
здесь компилятор инициализирует переменную value нулями, помещает её в бинарный файл, а при
первом вызове функции, возможно захватит рекурсивный мьютекс, присвоит значение и отпустит
мьютекс. 

Если в коде
  void f() {
    static const f = create(5);
  },

функция create - не constexpr, выполнится жесть с мьютексами, описанная выше. Иначе -
компилятор проинициализирует переменную на этапе компиляции и поместит её в бинарник.

Constexpr позволяет:
1) Использовать функции для вычисления констант;
2) Вычислять константы;
3) Статически инициализировать объекты;
4) Оптимизировать код;
5) Проверять на UB.
