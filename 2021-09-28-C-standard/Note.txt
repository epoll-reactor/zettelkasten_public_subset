Терминология

access - доступ к модификации значения объекта
alignment - требование к расположению объекта под адресами, кратными размеру байта
argument - список параметров, разделённых запятой
implementation-defined behaviour - поведение, которое документируется конкретной реализацией
locale-specific behaviour - поведение, зависящее от национальных, культурных соглашений
undefined behaviour - поведение неправильно построенного или не-кросплатформенного кода
unspecified behaviour - поведение, вызванное неправильным использованием (неверные аргументы)
runtime constraint - ограничение, накладываемое стандартной библиотекой
ceiling - округление в большую сторону (2.4 -> 3, -2.4 -> -2)
floor - округление в меньшую сторону (2.4 -> 2, -2.4 -> -3)

Запись и чтение двух не-атомик битовых полей не безопасно.

Программа содержащая #error не должна быть компилирована, исключая те случаи, когда #error
отключен путём условного препроцессирования.

Триграфы - специальные символы, использующиеся препроцессором.

+----------+-----+-----+-----+-----+-----+-----+-----+-----+-----+
| Symbol   |   # |   \ |   ^ |   [ |   ] |   | |   { |   } |   ~ |
+----------+-----+-----+-----+-----+-----+-----+-----+-----+-----+
| Trigraph | ??= | ??/ | ??' | ??( | ??) | ??! | ??< | ??> | ??- |
+----------+-----+-----+-----+-----+-----+-----+-----+-----+-----+

Фазы трансляции программы на С:
  1) Триграфы заменяются на соответствующие им символы
  2) Каждый символ '\' и следующий за ним '\n' удаляется. Каждый не пустой файл должен заканчи-
     ваться пустой строкой.
  3) Исходный файл разбивается на токены препроцессора и пробельные символы. Каждый комментарий
     заменяется одним пробельным символом. Символы переноса строки сохраняются. Всякое непустое
     множество пробельных символов заменяется одним пробельным символом.
  4) Директивы препроцессора раскрываются рекурсивно с 1 до 4 фазы. Выполняются макросы и
     _Pragma. Все определения директив препроцессора затем удаляются.
  5) Раскрываются экранированные символы.
  6) Соседствующие строковые литералы соединяются.
  7) Пробельные символы, разделяющие токены препроцессора более не нужны. Токен препроцессора
     преобразуется в токен парсинга.
  8) Происходит линковка внешних библиотек.

Все объекты со статическим временим жизни должны быть инициализированы до начала выполнения
main().

Когда поток выполнения доходит до последней '}' в main, возвращается 0.

Выполнение А зависит от выполнения В если:
  Значение А используется как операнд для В, пока:
    1) В - результат выполнения макроса kill_dependency
    2) А - левый операнд `&&`, `||`, `?:` и `,` оператора

  А записывает битовое поле М, В читает из М значение, записанное в А
   
  При выполнении Х, А зависит от Х, Х зависит от В

Существует 2 набора символов: исходный и набор времени выполнения.
Набор символов языка Си:
a-z A-Z 0-9 '\ ' '\t' '\v' '\f'
! " # % & ’ ( ) * + , - . / :
; < = > ? [ \ ] ^ _ { | } ~

Идентификатор может представлять объект, функцию, тег или член структуры, объединения или пере-
числения, typedef, метку goto, макрос или параметр макроса.

linkage - механизм, позволяющий нескольким идентификаторам указывать на одну и ту же сущность.
Если идентификатор файлового скоупа имеет модификатор static, он имеет внутреннюю линковку.
Если идентификатор имеет модификатор extern, он имеет внешнюю линковку. Это значит, что этот
идентификатор ссылается на объект в другом юните трансляции.
Если идентификатор не имеет static/extern модификаторов, он имеет внешнюю линковку.

Lifetime - момент выполнения программы, в течение которого гарантируется, что память будет
сохранена для выделенного объекта.

Все объекты, не имеющие _Thread_local, а так же с внешней или внутренней линковкой, или с
модификатором static, имеют static storage duration. Значение таких переменных сохраняется один
раз, и хранится до конца жизни программы.

Объект с _Thread_local имеет thread storage duration. Он создаётся при запуске потока и унич-
тожается с его завершением. Существует одна копия объекта для каждого потока. Попытка получить
доступ к _Thread_local из другого потока implementation-defined.

Объект, созданный без static имеет automatic storage duration.

Комплексные числа: float _Complex, double _Complex и long double _Complex.

Арифметические типы и указатели называются скалярными типами.
Массивы и структуры называются агрегатными типами.

_Alignas служит для обозначения размера блока, к которому выравнивается каждый член структуры.
В следующем коде char и char[128] помещаются в блоки размером 64 байта. Нет разницы, к какому
члену применять оператор _Alignas, выравниваться будут все члены.

+-------------+-------------+-------------+
| x           | cacheline_1 | cacheline_2 |
+-------------+-------------+-------------+
0            64           128           192

#include <assert.h>
typedef struct {
  char x;
  _Alignas(64) char cacheline[128];
} data;
static_assert(sizeof(data) == 192);
int main() {}

_Alignof возвращает выравнивание типа. Исходя из кода выше:
static_assert(_Alignof(data) == 64);

У целочисленных типов есть "ранг" преобразования, описанный как:
  1) 2 целочисленных типа не должны иметь одинаковый ранг, даже если они имеют одинаковое
     представление.
  2) Ранг знакового типа должен быть больше рейтинга знакового типа с меньшей точностью(
     размерностью).
  3) Ранг long long int > long int > int > short int > signed char.
  4) Ранг знакового типа равен рейтингу беззнакового типа.
  5) Ранг встроенного целого типа > ранг стороннего типа.
  6) Ранг char == ранг signed char == ранг unsigned char.
  7) Ранг _Bool меньше всех остальных.
  8) Ранг enum'а == ранг соответствующего целого типа.

При преобразовании числа с плавающей точкой в целое, отсекается мантисса.

Указатели
1) void* может быть преобразован в любой другой указательный тип и обратно.
2) Не-CV указатель может быть преобразован в такой же CV-указатель.
3) Целочисленная константа 0 или void* cо значением 0 называется null pointer constant.
4) Null-указателя одного типа равен null-указателю другого.
5) Целое число может быть преобразовано в указатель.
6) Указатель может быть преобразован в целое число.
7) Указатель на функцию одного типа может быть преобразован в указатель на функцию другого типа.

Ключевые слова:

 +-----------------+-----------------+-----------------+-----------------+
 |            auto |          extern |           short |           while |
 |           break |           float |          signed |        _Alignas |
 |            case |             for |          sizeof |        _Alignof |
 |            char |            goto |          static |         _Atomic |
 |           const |              if |          struct |           _Bool |
 |        continue |          inline |          switch |        _Complex |
 |         default |             int |         typedef |        _Generic |
 |              do |            long |           union |      _Imaginary |
 |          double |        register |        unsigned |       _Noreturn |
 |            else |        restrict |            void |  _Static_assert |
 |            enum |          return |        volatile |   _Thread_local |
 +-----------------+-----------------+-----------------+-----------------+

 _Imaginary зарезервирован.

 _Generic:

#include <stdio.h>
#include <math.h>
 
short short_f(short i) { printf("short_f(%d);\n", i); return i; }
int     int_f(  int i) { printf("int_f(%d);\n",   i); return i; }
long   long_f( long i) { printf("long_f(%ld);\n", i); return i; }
 
int main() {
  short i = 123;
  printf("%d", _Generic(i,
    short: short_f,
    int:     int_f,
    long:   long_f,
    default:  exit
  )(i));
}
 
В вызове (*pf[f1()])(f2(), f3() + f4()), f1, f2, f3, f4 могут быть вызваны в любом порядке.

"123", (char[]){"123"} и (const char[]){"123"} - разные выражения.

Директива препроцессора '#' не имеет эффекта.

#
#
#
int main() {} -  валидный код.

Обязательные макросы:

__DATE__         - "mmm dd yyyy".
__FILE__         - Название текущего файла.
__LINE__         - Номер текущей строки.
__STDC__         - 1 если реализация соответствует стандарту, иначе 0.
__STDC_HOSTED__  - 1 если hosted реализация, иначе 0.
__STDC_VERSION__ - константа yyyymmL.
__TIME__         - "hh:mm:ss"

_Pragma ("listing on \"..\\listing.dir\"") == #pragma listing on "..\listing.dir"

Продолжить с 7. Library
